// Generated by dts-bundle-generator v9.5.1

import { CloudEvent } from '@dynatrace-sdk/client-classic-environment-v2';

export type SoxErrorType = "Invalid Log Format" | "Integration Failure" | "Missing Transaction" | "Field Validation Error" | "Field Value Mismatch";
export type SoxErrorSubType = "Missing Integration Id" | "Missing or invalid Transaction ID" | "Missing Payload" | "Missing Transaction ID" | "Missing Timestamp" | "Integration Failure" | "Missing Transaction" | "Missing Field" | "Missing Value" | "Invalid Field Format" | "Value Mismatch";
export type SoxEventType = "OK" | "ERROR";
export interface SoxBusinessEvent {
	timestamp: string;
	eventId: string;
	eventProvider: "SOX";
	eventType: SoxEventType;
	srcEventTime: string;
	destEventTime: string;
	errorType?: SoxErrorType;
	errorSubType?: SoxErrorSubType;
	errorSummary?: string;
	transactionId: string;
	sourceIntId: string;
	destIntId: string;
	sourceData?: string;
	destinationData?: string;
}
export interface IngestResult {
	success: boolean;
	status?: number;
	error?: unknown;
	cloudEvent: CloudEvent;
	message: string;
	sourceDataTruncated?: boolean;
	destinationDataTruncated?: boolean;
}
export declare function toCloudEvent(sox: SoxBusinessEvent): {
	cloudEvent: CloudEvent;
	sourceDataTruncated: boolean;
	destinationDataTruncated: boolean;
};
export declare function createBusinessEvent(soxEvent: SoxBusinessEvent): Promise<IngestResult>;
export declare const Validators: {
	isEmpty(value: Object): boolean;
	validateAsyncSoxWrapper(value: unknown): {
		isValid: boolean;
		errorMessages: string[];
	};
	validateHttpSoxWrapper(value: unknown): {
		isValid: boolean;
		errorMessages: string[];
	};
	_extractBusinessPayload(input: unknown): unknown;
	_flattenToPathValueMap(root: any): Record<string, unknown>;
	validatePayloadWithRules(ruleMap: Record<string, RegExp>, payload: unknown): {
		isValid: boolean;
		errorMessages: string[];
		failures: {
			rulePath: string;
			actualPath: string;
			value: unknown;
			reason: string;
		}[];
	};
	comparePayloadsWithFieldMap(fieldPathMap: Record<string, string>, sourcePayload: unknown, destinationPayload: unknown): {
		isValid: boolean;
		errorMessages: string[];
		missingSource: string[];
		missingDestination: string[];
		mismatches: {
			sourcePath: string;
			destinationPath: string;
			mappedSourceRule: string;
			mappedDestinationRule: string;
			sourceValue: unknown;
			destinationValue: unknown;
			reason: string;
		}[];
	};
};
export interface ValidatePairParams {
	sourceIntegrationId: string;
	destinationIntegrationId: string;
	sourcePayload: unknown;
	destinationPayload: unknown;
}
export interface ValidateIntegrationParams {
	integrationId: string;
	payload: unknown;
}
export interface PayloadRuleValidationResult {
	isValid: boolean;
	errorMessages: string[];
	failures: {
		rulePath: string;
		actualPath: string;
		value: unknown;
		reason: string;
	}[];
}
export interface MappingComparisonResult {
	isValid: boolean;
	errorMessages: string[];
	missingSource: string[];
	missingDestination: string[];
	mismatches: {
		sourcePath: string;
		destinationPath: string;
		mappedSourceRule: string;
		mappedDestinationRule: string;
		sourceValue: unknown;
		destinationValue: unknown;
		reason: string;
	}[];
}
export interface IntegrationValidationResult {
	sourceIntegrationId: string;
	destinationIntegrationId: string;
	sourceValidation?: PayloadRuleValidationResult;
	destinationValidation?: PayloadRuleValidationResult;
	mappingComparison?: MappingComparisonResult | null;
	isValid: boolean;
	errors: string[];
}
export interface SingleIntegrationValidationResult {
	integrationId: string;
	validation?: PayloadRuleValidationResult;
	isValid: boolean;
	errors: string[];
}
export declare function validateIntegration(params: ValidateIntegrationParams): SingleIntegrationValidationResult;
export declare function validateIntegrationPair(params: ValidatePairParams): IntegrationValidationResult;
declare const _default: {
	validateIntegration: typeof validateIntegration;
	validateIntegrationPair: typeof validateIntegrationPair;
	Validators: {
		isEmpty(value: Object): boolean;
		validateAsyncSoxWrapper(value: unknown): {
			isValid: boolean;
			errorMessages: string[];
		};
		validateHttpSoxWrapper(value: unknown): {
			isValid: boolean;
			errorMessages: string[];
		};
		_extractBusinessPayload(input: unknown): unknown;
		_flattenToPathValueMap(root: any): Record<string, unknown>;
		validatePayloadWithRules(ruleMap: Record<string, RegExp>, payload: unknown): {
			isValid: boolean;
			errorMessages: string[];
			failures: {
				rulePath: string;
				actualPath: string;
				value: unknown;
				reason: string;
			}[];
		};
		comparePayloadsWithFieldMap(fieldPathMap: Record<string, string>, sourcePayload: unknown, destinationPayload: unknown): {
			isValid: boolean;
			errorMessages: string[];
			missingSource: string[];
			missingDestination: string[];
			mismatches: {
				sourcePath: string;
				destinationPath: string;
				mappedSourceRule: string;
				mappedDestinationRule: string;
				sourceValue: unknown;
				destinationValue: unknown;
				reason: string;
			}[];
		};
	};
	createBusinessEvent: typeof createBusinessEvent;
	toCloudEvent: typeof toCloudEvent;
};

export {
	_default as default,
};

export {};
